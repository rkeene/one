#!/bin/bash

# -------------------------------------------------------------------------- #
# Copyright 2002-2016, OpenNebula Project, OpenNebula Systems                #
#                                                                            #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    #
# not use this file except in compliance with the License. You may obtain    #
# a copy of the License at                                                   #
#                                                                            #
# http://www.apache.org/licenses/LICENSE-2.0                                 #
#                                                                            #
# Unless required by applicable law or agreed to in writing, software        #
# distributed under the License is distributed on an "AS IS" BASIS,          #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
# See the License for the specific language governing permissions and        #
# limitations under the License.                                             #
#--------------------------------------------------------------------------- #

source $(dirname $0)/kvmrc
source $(dirname $0)/../../scripts_common.sh

DOMAIN="$1"
SNAP_ID="$2"

data="$(virsh --connect $LIBVIRT_URI snapshot-create-as $DOMAIN 2>&1)"

if [ "$?" = "0" ]; then
    echo "$data" | awk '{print $3}'
    exit 0
fi

function generateSnapshotCommands() {
	local internalSnapshotName
	local xml idx

	internalSnapshotName="$1"

	# Get the current configuration
	xml="$(virsh --connect $LIBVIRT_URI dumpxml $DOMAIN 2>/dev/null)"

	# Process every disk from the XML
	idx='0'
	while true; do
		idx=$[$idx + 1]
		(
			IFS='' read -r -d '' type
			IFS='' read -r -d '' device
			IFS='' read -r -d '' sourceProtocol
			IFS='' read -r -d '' sourceName
			IFS='' read -r -d '' sourceFile
			IFS='' read -r -d '' driverName
			IFS='' read -r -d '' driverType

			# Skip CD-ROMs from snapshots
			if [ "${device}" = "cdrom" ]; then
				exit 0
			fi
			if [ -z "${type}" ]; then
				exit 2
			fi

			case "${driverType}" in
				raw)
					case "${type}" in
						network)
							case "${sourceProtocol}" in
								rbd)
									echo "rbd snap create ${sourceName}@${internalSnapshotName}"
									;;
								*)
									error_message "Could not create snapshot $NAME for domain $DOMAIN: network disk protocol $sourceProtocol found"
									exit -1
									;;
							esac
							;;
						file)
							error_message "Could not create snapshot $NAME for domain $DOMAIN: raw file found"
							exit -1
							;;
						*)
							error_message "Could not create snapshot $NAME for domain $DOMAIN: Unsupported libvirt disk type $type found"
							exit -1
							;;
					esac
					;;
				qcow2)
					case "${type}" in
						network)
							error_message "Could not create snapshot $NAME for domain $DOMAIN: unsupported qcow2 on network device"
							exit -1
							;;
						file)
							echo "sudo qemu-img snapshot -c ${internalSnapshotName} $(set | awk -v var="sourceFile" '($0 ~ "^" var "="){ gsub("^" var "=", ""); print }')"
							;;
						*)
							error_message "Could not create snapshot $NAME for domain $DOMAIN: Unsupported libvirt disk type $type found"
							exit -1
							;;
					esac
					;;
				*)
					error_message "Could not create snapshot $NAME for domain $DOMAIN: Unsupported libvirt driver type $driverType found"
					exit -1
					;;
			esac
		) < <(echo "${xml}" | /var/tmp/one/datastore/xpath.rb \
			'/domain/devices/disk['"${idx}"']/@type' \
			'/domain/devices/disk['"${idx}"']/@device' \
			'/domain/devices/disk['"${idx}"']/source/@protocol' \
			'/domain/devices/disk['"${idx}"']/source/@name' \
			'/domain/devices/disk['"${idx}"']/source/@file' \
			'/domain/devices/disk['"${idx}"']/driver/@name' \
			'/domain/devices/disk['"${idx}"']/driver/@type')

		case "$?" in
			0)
				;;
			2)
				break
				;;
			*)
				return 1
				;;
		esac
	done
}

case "${data}" in
	*'internal snapshot for disk '*' unsupported for storage type'*)
		# Take a snapshot directly
		## Determine the internal name to create
		internalSnapshotName="one-$(uuidgen -r)"

		## Determine what to run to create the snapshot
		commandsToRun="$(generateSnapshotCommands "${internalSnapshotName}")" || ( error_message "Could not create snapshot $NAME for domain $DOMAIN."; exit 1 ) || exit -1
		commandsToRunCount="$(echo "${commandsToRun}" | wc -l | awk '{ print $1 }')"

		# If we came up with nothing to do, fail
		if [ "${commandsToRunCount}" = '0' ]; then
			error_message "Could not create snapshot $NAME for domain $DOMAIN: No way to take a snapshot of any disks"
			exit -1
		fi

		## Run the commands, pausing the VM if needed
		if [ "${commandsToRunCount}" -gt '1' ]; then
			virsh --connect $LIBVIRT_URI qemu-monitor-command --domain $DOMAIN --hmp --cmd stop >/dev/null
		fi

		failed='0'
		results="$(
			(
				echo "set -e"
				echo "${commandsToRun}"
			) | sh - 2>&1
		)" || failed='1'

		if [ "${commandsToRunCount}" -gt '1' ]; then
			virsh --connect $LIBVIRT_URI qemu-monitor-command --domain $DOMAIN --hmp --cmd cont >/dev/null
		fi

		if [ "${failed}" = '1' ]; then
			error_message "Could not create snapshot $NAME for domain $DOMAIN: $results"

			exit -1
		fi

		echo "${internalSnapshotName}"
		;;
	*)
		error_message "Could not create snapshot $NAME for domain $DOMAIN."
 		exit -1
		;;
esac

exit 0
